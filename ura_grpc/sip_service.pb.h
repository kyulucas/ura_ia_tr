// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sip_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sip_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sip_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sip_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sip_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sip_5fservice_2eproto;
namespace sipservice {
class AudioChunk;
struct AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class CallEvent;
struct CallEventDefaultTypeInternal;
extern CallEventDefaultTypeInternal _CallEvent_default_instance_;
class CallRequest;
struct CallRequestDefaultTypeInternal;
extern CallRequestDefaultTypeInternal _CallRequest_default_instance_;
class CallResponse;
struct CallResponseDefaultTypeInternal;
extern CallResponseDefaultTypeInternal _CallResponse_default_instance_;
class EventSubscriptionRequest;
struct EventSubscriptionRequestDefaultTypeInternal;
extern EventSubscriptionRequestDefaultTypeInternal _EventSubscriptionRequest_default_instance_;
class HangupRequest;
struct HangupRequestDefaultTypeInternal;
extern HangupRequestDefaultTypeInternal _HangupRequest_default_instance_;
class HangupResponse;
struct HangupResponseDefaultTypeInternal;
extern HangupResponseDefaultTypeInternal _HangupResponse_default_instance_;
}  // namespace sipservice
PROTOBUF_NAMESPACE_OPEN
template<> ::sipservice::AudioChunk* Arena::CreateMaybeMessage<::sipservice::AudioChunk>(Arena*);
template<> ::sipservice::CallEvent* Arena::CreateMaybeMessage<::sipservice::CallEvent>(Arena*);
template<> ::sipservice::CallRequest* Arena::CreateMaybeMessage<::sipservice::CallRequest>(Arena*);
template<> ::sipservice::CallResponse* Arena::CreateMaybeMessage<::sipservice::CallResponse>(Arena*);
template<> ::sipservice::EventSubscriptionRequest* Arena::CreateMaybeMessage<::sipservice::EventSubscriptionRequest>(Arena*);
template<> ::sipservice::HangupRequest* Arena::CreateMaybeMessage<::sipservice::HangupRequest>(Arena*);
template<> ::sipservice::HangupResponse* Arena::CreateMaybeMessage<::sipservice::HangupResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sipservice {

enum EventType : int {
  UNKNOWN = 0,
  CALL_RINGING = 1,
  CALL_ESTABLISHED = 2,
  CALL_TERMINATED = 3,
  INCOMING_CALL = 4,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = UNKNOWN;
constexpr EventType EventType_MAX = INCOMING_CALL;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
// ===================================================================

class CallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.CallRequest) */ {
 public:
  inline CallRequest() : CallRequest(nullptr) {}
  ~CallRequest() override;
  explicit PROTOBUF_CONSTEXPR CallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallRequest(const CallRequest& from);
  CallRequest(CallRequest&& from) noexcept
    : CallRequest() {
    *this = ::std::move(from);
  }

  inline CallRequest& operator=(const CallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallRequest& operator=(CallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallRequest* internal_default_instance() {
    return reinterpret_cast<const CallRequest*>(
               &_CallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CallRequest& a, CallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallRequest& from) {
    CallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.CallRequest";
  }
  protected:
  explicit CallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kDestinationFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string destination = 2;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // @@protoc_insertion_point(class_scope:sipservice.CallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.CallResponse) */ {
 public:
  inline CallResponse() : CallResponse(nullptr) {}
  ~CallResponse() override;
  explicit PROTOBUF_CONSTEXPR CallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallResponse(const CallResponse& from);
  CallResponse(CallResponse&& from) noexcept
    : CallResponse() {
    *this = ::std::move(from);
  }

  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponse& operator=(CallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponse* internal_default_instance() {
    return reinterpret_cast<const CallResponse*>(
               &_CallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CallResponse& a, CallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallResponse& from) {
    CallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.CallResponse";
  }
  protected:
  explicit CallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallIdFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string call_id = 2;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sipservice.CallResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HangupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.HangupRequest) */ {
 public:
  inline HangupRequest() : HangupRequest(nullptr) {}
  ~HangupRequest() override;
  explicit PROTOBUF_CONSTEXPR HangupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupRequest(const HangupRequest& from);
  HangupRequest(HangupRequest&& from) noexcept
    : HangupRequest() {
    *this = ::std::move(from);
  }

  inline HangupRequest& operator=(const HangupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupRequest& operator=(HangupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupRequest* internal_default_instance() {
    return reinterpret_cast<const HangupRequest*>(
               &_HangupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HangupRequest& a, HangupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupRequest& from) {
    HangupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.HangupRequest";
  }
  protected:
  explicit HangupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallIdFieldNumber = 1,
  };
  // string call_id = 1;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // @@protoc_insertion_point(class_scope:sipservice.HangupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HangupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.HangupResponse) */ {
 public:
  inline HangupResponse() : HangupResponse(nullptr) {}
  ~HangupResponse() override;
  explicit PROTOBUF_CONSTEXPR HangupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupResponse(const HangupResponse& from);
  HangupResponse(HangupResponse&& from) noexcept
    : HangupResponse() {
    *this = ::std::move(from);
  }

  inline HangupResponse& operator=(const HangupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupResponse& operator=(HangupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupResponse* internal_default_instance() {
    return reinterpret_cast<const HangupResponse*>(
               &_HangupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HangupResponse& a, HangupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupResponse& from) {
    HangupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.HangupResponse";
  }
  protected:
  explicit HangupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sipservice.HangupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AudioChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  ~AudioChunk() override;
  explicit PROTOBUF_CONSTEXPR AudioChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioChunk(const AudioChunk& from);
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioChunk& from) {
    AudioChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.AudioChunk";
  }
  protected:
  explicit AudioChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSampleRateFieldNumber = 2,
    kChannelsFieldNumber = 3,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 sample_rate = 2;
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // int32 channels = 3;
  void clear_channels();
  int32_t channels() const;
  void set_channels(int32_t value);
  private:
  int32_t _internal_channels() const;
  void _internal_set_channels(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sipservice.AudioChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t sample_rate_;
    int32_t channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EventSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.EventSubscriptionRequest) */ {
 public:
  inline EventSubscriptionRequest() : EventSubscriptionRequest(nullptr) {}
  ~EventSubscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR EventSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSubscriptionRequest(const EventSubscriptionRequest& from);
  EventSubscriptionRequest(EventSubscriptionRequest&& from) noexcept
    : EventSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline EventSubscriptionRequest& operator=(const EventSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubscriptionRequest& operator=(EventSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const EventSubscriptionRequest*>(
               &_EventSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventSubscriptionRequest& a, EventSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSubscriptionRequest& from) {
    EventSubscriptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.EventSubscriptionRequest";
  }
  protected:
  explicit EventSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:sipservice.EventSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CallEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sipservice.CallEvent) */ {
 public:
  inline CallEvent() : CallEvent(nullptr) {}
  ~CallEvent() override;
  explicit PROTOBUF_CONSTEXPR CallEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallEvent(const CallEvent& from);
  CallEvent(CallEvent&& from) noexcept
    : CallEvent() {
    *this = ::std::move(from);
  }

  inline CallEvent& operator=(const CallEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallEvent& operator=(CallEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallEvent* internal_default_instance() {
    return reinterpret_cast<const CallEvent*>(
               &_CallEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CallEvent& a, CallEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CallEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallEvent& from) {
    CallEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sipservice.CallEvent";
  }
  protected:
  explicit CallEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallIdFieldNumber = 1,
    kDetailsFieldNumber = 3,
    kEventTypeFieldNumber = 2,
  };
  // string call_id = 1;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string details = 3;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // .sipservice.EventType event_type = 2;
  void clear_event_type();
  ::sipservice::EventType event_type() const;
  void set_event_type(::sipservice::EventType value);
  private:
  ::sipservice::EventType _internal_event_type() const;
  void _internal_set_event_type(::sipservice::EventType value);
  public:

  // @@protoc_insertion_point(class_scope:sipservice.CallEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
    int event_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sip_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CallRequest

// string account_id = 1;
inline void CallRequest::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& CallRequest::account_id() const {
  // @@protoc_insertion_point(field_get:sipservice.CallRequest.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRequest::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallRequest.account_id)
}
inline std::string* CallRequest::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:sipservice.CallRequest.account_id)
  return _s;
}
inline const std::string& CallRequest::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void CallRequest::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRequest::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:sipservice.CallRequest.account_id)
  return _impl_.account_id_.Release();
}
inline void CallRequest::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallRequest.account_id)
}

// string destination = 2;
inline void CallRequest::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& CallRequest::destination() const {
  // @@protoc_insertion_point(field_get:sipservice.CallRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallRequest.destination)
}
inline std::string* CallRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:sipservice.CallRequest.destination)
  return _s;
}
inline const std::string& CallRequest::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void CallRequest::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRequest::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRequest::release_destination() {
  // @@protoc_insertion_point(field_release:sipservice.CallRequest.destination)
  return _impl_.destination_.Release();
}
inline void CallRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallRequest.destination)
}

// -------------------------------------------------------------------

// CallResponse

// bool success = 1;
inline void CallResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CallResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CallResponse::success() const {
  // @@protoc_insertion_point(field_get:sipservice.CallResponse.success)
  return _internal_success();
}
inline void CallResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CallResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sipservice.CallResponse.success)
}

// string call_id = 2;
inline void CallResponse::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& CallResponse::call_id() const {
  // @@protoc_insertion_point(field_get:sipservice.CallResponse.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallResponse::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallResponse.call_id)
}
inline std::string* CallResponse::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sipservice.CallResponse.call_id)
  return _s;
}
inline const std::string& CallResponse::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void CallResponse::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallResponse::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallResponse::release_call_id() {
  // @@protoc_insertion_point(field_release:sipservice.CallResponse.call_id)
  return _impl_.call_id_.Release();
}
inline void CallResponse::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallResponse.call_id)
}

// string error_message = 3;
inline void CallResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& CallResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sipservice.CallResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallResponse.error_message)
}
inline std::string* CallResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sipservice.CallResponse.error_message)
  return _s;
}
inline const std::string& CallResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void CallResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CallResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CallResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sipservice.CallResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void CallResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallResponse.error_message)
}

// -------------------------------------------------------------------

// HangupRequest

// string call_id = 1;
inline void HangupRequest::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& HangupRequest::call_id() const {
  // @@protoc_insertion_point(field_get:sipservice.HangupRequest.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupRequest::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.HangupRequest.call_id)
}
inline std::string* HangupRequest::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sipservice.HangupRequest.call_id)
  return _s;
}
inline const std::string& HangupRequest::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void HangupRequest::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupRequest::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupRequest::release_call_id() {
  // @@protoc_insertion_point(field_release:sipservice.HangupRequest.call_id)
  return _impl_.call_id_.Release();
}
inline void HangupRequest::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.HangupRequest.call_id)
}

// -------------------------------------------------------------------

// HangupResponse

// bool success = 1;
inline void HangupResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool HangupResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool HangupResponse::success() const {
  // @@protoc_insertion_point(field_get:sipservice.HangupResponse.success)
  return _internal_success();
}
inline void HangupResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void HangupResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sipservice.HangupResponse.success)
}

// string error_message = 2;
inline void HangupResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& HangupResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sipservice.HangupResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.HangupResponse.error_message)
}
inline std::string* HangupResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sipservice.HangupResponse.error_message)
  return _s;
}
inline const std::string& HangupResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void HangupResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sipservice.HangupResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void HangupResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.HangupResponse.error_message)
}

// -------------------------------------------------------------------

// AudioChunk

// bytes data = 1;
inline void AudioChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& AudioChunk::data() const {
  // @@protoc_insertion_point(field_get:sipservice.AudioChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.AudioChunk.data)
}
inline std::string* AudioChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sipservice.AudioChunk.data)
  return _s;
}
inline const std::string& AudioChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void AudioChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioChunk::release_data() {
  // @@protoc_insertion_point(field_release:sipservice.AudioChunk.data)
  return _impl_.data_.Release();
}
inline void AudioChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.AudioChunk.data)
}

// int32 sample_rate = 2;
inline void AudioChunk::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
}
inline int32_t AudioChunk::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t AudioChunk::sample_rate() const {
  // @@protoc_insertion_point(field_get:sipservice.AudioChunk.sample_rate)
  return _internal_sample_rate();
}
inline void AudioChunk::_internal_set_sample_rate(int32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void AudioChunk::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:sipservice.AudioChunk.sample_rate)
}

// int32 channels = 3;
inline void AudioChunk::clear_channels() {
  _impl_.channels_ = 0;
}
inline int32_t AudioChunk::_internal_channels() const {
  return _impl_.channels_;
}
inline int32_t AudioChunk::channels() const {
  // @@protoc_insertion_point(field_get:sipservice.AudioChunk.channels)
  return _internal_channels();
}
inline void AudioChunk::_internal_set_channels(int32_t value) {
  
  _impl_.channels_ = value;
}
inline void AudioChunk::set_channels(int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:sipservice.AudioChunk.channels)
}

// -------------------------------------------------------------------

// EventSubscriptionRequest

// string client_id = 1;
inline void EventSubscriptionRequest::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& EventSubscriptionRequest::client_id() const {
  // @@protoc_insertion_point(field_get:sipservice.EventSubscriptionRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventSubscriptionRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.EventSubscriptionRequest.client_id)
}
inline std::string* EventSubscriptionRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:sipservice.EventSubscriptionRequest.client_id)
  return _s;
}
inline const std::string& EventSubscriptionRequest::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void EventSubscriptionRequest::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubscriptionRequest::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EventSubscriptionRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:sipservice.EventSubscriptionRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void EventSubscriptionRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.EventSubscriptionRequest.client_id)
}

// -------------------------------------------------------------------

// CallEvent

// string call_id = 1;
inline void CallEvent::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& CallEvent::call_id() const {
  // @@protoc_insertion_point(field_get:sipservice.CallEvent.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEvent::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallEvent.call_id)
}
inline std::string* CallEvent::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sipservice.CallEvent.call_id)
  return _s;
}
inline const std::string& CallEvent::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void CallEvent::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEvent::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEvent::release_call_id() {
  // @@protoc_insertion_point(field_release:sipservice.CallEvent.call_id)
  return _impl_.call_id_.Release();
}
inline void CallEvent::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallEvent.call_id)
}

// .sipservice.EventType event_type = 2;
inline void CallEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::sipservice::EventType CallEvent::_internal_event_type() const {
  return static_cast< ::sipservice::EventType >(_impl_.event_type_);
}
inline ::sipservice::EventType CallEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sipservice.CallEvent.event_type)
  return _internal_event_type();
}
inline void CallEvent::_internal_set_event_type(::sipservice::EventType value) {
  
  _impl_.event_type_ = value;
}
inline void CallEvent::set_event_type(::sipservice::EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:sipservice.CallEvent.event_type)
}

// string details = 3;
inline void CallEvent::clear_details() {
  _impl_.details_.ClearToEmpty();
}
inline const std::string& CallEvent::details() const {
  // @@protoc_insertion_point(field_get:sipservice.CallEvent.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEvent::set_details(ArgT0&& arg0, ArgT... args) {
 
 _impl_.details_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sipservice.CallEvent.details)
}
inline std::string* CallEvent::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:sipservice.CallEvent.details)
  return _s;
}
inline const std::string& CallEvent::_internal_details() const {
  return _impl_.details_.Get();
}
inline void CallEvent::_internal_set_details(const std::string& value) {
  
  _impl_.details_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEvent::_internal_mutable_details() {
  
  return _impl_.details_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEvent::release_details() {
  // @@protoc_insertion_point(field_release:sipservice.CallEvent.details)
  return _impl_.details_.Release();
}
inline void CallEvent::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  _impl_.details_.SetAllocated(details, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sipservice.CallEvent.details)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sipservice

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sipservice::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sipservice::EventType>() {
  return ::sipservice::EventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sip_5fservice_2eproto
